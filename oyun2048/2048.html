<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>2048 Oyunu</title>
  <link rel="icon" href="dosyalar/resimler/asillogo.png" type="image/x-icon">
  <style>
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
      background-color: #faf8ef;
      font-family: Arial, sans-serif;
      overflow: hidden;
      touch-action: none;
    }

    .board {
      position: relative;
      width: 420px;
      height: 420px;
      background: #bbada0;
      border-radius: 10px;
      display: grid;
      grid-template-columns: repeat(4, 100px);
      grid-template-rows: repeat(4, 100px);
      gap: 5px;
      padding: 5px;
      box-shadow: 0 6px 18px rgba(0,0,0,0.15);
    }

    .cell {
      width: 100px;
      height: 100px;
      background: #cdc1b4;
      border-radius: 5px;
    }

    .tile-layer {
      position: absolute;
      left: 5px;
      top: 5px;
      width: 410px;
      height: 410px;
      pointer-events: none;
      z-index: 5;
    }

    .tile {
      position: absolute;
      width: 100px;
      height: 100px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 28px;
      font-weight: bold;
      border-radius: 5px;
      transition: left 140ms cubic-bezier(.2,.8,.2,1), top 140ms cubic-bezier(.2,.8,.2,1), opacity 120ms linear, background-color 120ms ease;
      box-shadow: 0 4px 8px rgba(0,0,0,0.15);
      will-change: left, top, opacity;
    }

    .tile .inner {
      width: 100%;
      height: 100%;
      display:flex;
      justify-content:center;
      align-items:center;
      border-radius:5px;
    }

    .message {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 32px;
      font-weight: bold;
      color: #333;
      display: none;
      background: #fff;
      padding: 15px 25px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      z-index: 20;
    }

    .val-2 { background: #eee4da; color: #776e65; }
    .val-4 { background: #ede0c8; color: #776e65; }
    .val-8 { background: #f2b179; color: #f9f6f2; }
    .val-16 { background: #f59563; color: #f9f6f2; }
    .val-32 { background: #f67c5f; color: #f9f6f2; }
    .val-64 { background: #f65e3b; color: #f9f6f2; }
    .val-128 { background: #edcf72; color: #f9f6f2; font-size:24px; }
    .val-256 { background: #edcc61; color: #f9f6f2; font-size:24px; }
    .val-512 { background: #edc850; color: #f9f6f2; font-size:24px; }
    .val-1024 { background: #edc53f; color: #f9f6f2; font-size:22px; }
    .val-2048 { background: #edc22e; color: #f9f6f2; font-size:22px; }

    @media (max-width: 480px) {
      .board { width: 92vw; height: 92vw; grid-template-columns: repeat(4, 1fr); grid-template-rows: repeat(4, 1fr); gap: 3.5vw; padding: 3.5vw; border-radius: 2.5vw; }
      .cell { width: calc((92vw - 2*3.5vw - 3*3.5vw)/4); height: calc((92vw - 2*3.5vw - 3*3.5vw)/4); border-radius: 1.2vw; }
      .tile-layer { left: 3.5vw; top: 3.5vw; width: calc(92vw - 2*3.5vw); height: calc(92vw - 2*3.5vw); }
      .tile { width: calc((92vw - 2*3.5vw - 3*3.5vw)/4); height: calc((92vw - 2*3.5vw - 3*3.5vw)/4); border-radius: 1.2vw; font-size: 6vw; }
    }
  </style>
</head>
<body>
  <div class="board" id="board">
    <div class="message" id="message">Kaybettin!</div>

    <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
    <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
    <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
    <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>

    <div class="tile-layer" id="tileLayer"></div>
  </div>

  <script>
    const SIZE = 4;
    const boardElement = document.getElementById("board");
    const tileLayer = document.getElementById("tileLayer");
    const messageElement = document.getElementById("message");

    let board = Array.from({length: SIZE}, () => Array(SIZE).fill(0));
    let cellSize = 100;
    let domIdCounter = 0;
    const domTiles = {};

    function updateCellSize() {
      const layerRect = tileLayer.getBoundingClientRect();
      cellSize = layerRect.width / SIZE;
      for (const id in domTiles) {
        const t = domTiles[id];
        t.el.style.width = cellSize + 'px';
        t.el.style.height = cellSize + 'px';
        t.el.style.left = (t.c * cellSize) + 'px';
        t.el.style.top = (t.r * cellSize) + 'px';
      }
    }

    window.addEventListener('resize', () => {
      const bRect = boardElement.getBoundingClientRect();
      const pad = parseFloat(getComputedStyle(boardElement).paddingLeft) || 5;
      tileLayer.style.left = pad + 'px';
      tileLayer.style.top = pad + 'px';
      tileLayer.style.width = (bRect.width - 2*pad) + 'px';
      tileLayer.style.height = (bRect.width - 2*pad) + 'px';
      updateCellSize();
    });

    function valueClass(v) { return 'val-' + v; }

    function createDomTile(r, c, value, appear = true) {
      const id = ++domIdCounter;
      const el = document.createElement('div');
      el.className = 'tile';
      el.dataset.id = id;
      el.dataset.r = r;
      el.dataset.c = c;
      el.dataset.v = value;

      const inner = document.createElement('div');
      inner.className = 'inner ' + valueClass(value);
      inner.textContent = value;
      el.appendChild(inner);

      el.style.width = cellSize + 'px';
      el.style.height = cellSize + 'px';
      el.style.left = (c * cellSize) + 'px';
      el.style.top = (r * cellSize) + 'px';

      tileLayer.appendChild(el);
      domTiles[id] = {el, r, c, value};

      if (appear) {
        el.style.transform = 'scale(0.18)';
        el.style.opacity = '0';
        requestAnimationFrame(() => {
          el.style.transition = 'transform 120ms ease, opacity 120ms linear';
          el.style.transform = 'scale(1)';
          el.style.opacity = '1';
        });
      }

      return id;
    }

    function ensureStaticTargetUpdated(tgtR, tgtC, newValue) {
      // Hedef pozisyonda zaten bir statik tile varsa güncelle, yoksa oluştur
      for (const id in domTiles) {
        const t = domTiles[id];
        if (t.r === tgtR && t.c === tgtC) {
          t.value = newValue;
          t.el.dataset.v = newValue;
          const inner = t.el.querySelector('.inner');
          inner.textContent = newValue;
          inner.className = 'inner ' + valueClass(newValue);
          t.el.style.opacity = '1';
          return;
        }
      }
      // yoksa yeni statik oluştur (appear false çünkü hemen görünmeli)
      createDomTile(tgtR, tgtC, newValue, false);
    }

    function renderStaticFromBoard() {
      tileLayer.innerHTML = '';
      for (const k in domTiles) delete domTiles[k];
      domIdCounter = 0;
      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          if (board[r][c] !== 0) createDomTile(r, c, board[r][c], false);
        }
      }
    }

    function spawnTile() {
      const empty = [];
      for (let r = 0; r < SIZE; r++) for (let c = 0; c < SIZE; c++) if (board[r][c] === 0) empty.push([r, c]);
      if (empty.length === 0) return false;
      const [r, c] = empty[Math.floor(Math.random() * empty.length)];
      board[r][c] = Math.random() < 0.9 ? 2 : 4;
      createDomTile(r, c, board[r][c], true);
      return true;
    }

    function computeMoveAndMapping(srcBoard, direction) {
      const newBoard = Array.from({length: SIZE}, () => Array(SIZE).fill(0));
      const moves = [];
      function processLine(vals, coords) {
        const sources = [];
        for (let i = 0; i < vals.length; i++) if (vals[i] !== 0) sources.push({pos: coords[i], value: vals[i]});
        const result = [];
        const usedSources = [];
        let i = 0;
        while (i < sources.length) {
          if (i + 1 < sources.length && sources[i].value === sources[i+1].value) {
            result.push(sources[i].value * 2);
            usedSources.push([sources[i].pos, sources[i+1].pos]);
            i += 2;
          } else {
            result.push(sources[i].value);
            usedSources.push([sources[i].pos]);
            i += 1;
          }
        }
        while (result.length < SIZE) { result.push(0); usedSources.push([]); }
        return {result, usedSources};
      }

      if (direction === 'up' || direction === 'down') {
        for (let c = 0; c < SIZE; c++) {
          const vals = []; const coords = [];
          if (direction === 'up') for (let r = 0; r < SIZE; r++) { vals.push(srcBoard[r][c]); coords.push([r,c]); }
          else for (let r = SIZE-1; r >= 0; r--) { vals.push(srcBoard[r][c]); coords.push([r,c]); }
          const {result, usedSources} = processLine(vals, coords);
          for (let i = 0; i < SIZE; i++) {
            const tgt = (direction === 'up') ? [i, c] : [SIZE-1 - i, c];
            newBoard[tgt[0]][tgt[1]] = result[i];
            for (const srcPos of usedSources[i]) if (srcPos.length !== 0) moves.push({from: srcPos, to: tgt, value: result[i]});
          }
        }
      } else {
        for (let r = 0; r < SIZE; r++) {
          const vals = []; const coords = [];
          if (direction === 'left') for (let c = 0; c < SIZE; c++) { vals.push(srcBoard[r][c]); coords.push([r,c]); }
          else for (let c = SIZE-1; c >= 0; c--) { vals.push(srcBoard[r][c]); coords.push([r,c]); }
          const {result, usedSources} = processLine(vals, coords);
          for (let i = 0; i < SIZE; i++) {
            const tgt = (direction === 'left') ? [r, i] : [r, SIZE-1 - i];
            newBoard[tgt[0]][tgt[1]] = result[i];
            for (const srcPos of usedSources[i]) if (srcPos.length !== 0) moves.push({from: srcPos, to: tgt, value: result[i]});
          }
        }
      }

      return {newBoard, moves};
    }

    function isGameOver() {
      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          if (board[r][c] === 0) return false;
          const v = board[r][c];
          if (r + 1 < SIZE && board[r+1][c] === v) return false;
          if (c + 1 < SIZE && board[r][c+1] === v) return false;
        }
      }
      return true;
    }

    let animating = false;

    function move(direction) {
      if (animating) return;
      if (messageElement.style.display === 'block') return;
      const {newBoard, moves} = computeMoveAndMapping(board, direction);

      let changed = false;
      for (let r = 0; r < SIZE; r++) for (let c = 0; c < SIZE; c++) if (board[r][c] !== newBoard[r][c]) changed = true;
      if (!changed) {
        if (isGameOver()) { messageElement.style.display = 'block'; }
        return;
      }

      animating = true;

      const posMap = {};
      for (const id in domTiles) {
        const t = domTiles[id];
        const key = `${t.r},${t.c}`;
        if (!posMap[key]) posMap[key] = [];
        posMap[key].push(id);
      }

      const clones = [];
      // Ön hazırlık: her hedef için birleşecek yeni değeri hemen güncelle (görsel gecikmeyi azaltmak için)
      const targetUpdated = {}; // "r,c" -> newValue (birden fazla kaynak aynı hedefe gelirse aynı değer tekrar yazılır)
      moves.forEach(mv => {
        const key = `${mv.to[0]},${mv.to[1]}`;
        targetUpdated[key] = mv.value;
      });

      // Hedefleri önceden görsel olarak güncelle (ancak board verisi henüz güncellenmeyecek)
      for (const key in targetUpdated) {
        const [r,c] = key.split(',').map(Number);
        ensureStaticTargetUpdated(r, c, targetUpdated[key]);
      }

      for (const mv of moves) {
        const fromKey = `${mv.from[0]},${mv.from[1]}`;
        let sourceId = null;
        if (posMap[fromKey] && posMap[fromKey].length > 0) {
          sourceId = posMap[fromKey].shift();
        } else {
          sourceId = createDomTile(mv.from[0], mv.from[1], mv.value, false);
        }
        const source = domTiles[sourceId];
        const clone = source.el.cloneNode(true);
        clone.style.position = 'absolute';
        clone.style.width = cellSize + 'px';
        clone.style.height = cellSize + 'px';
        clone.style.left = (source.c * cellSize) + 'px';
        clone.style.top = (source.r * cellSize) + 'px';
        clone.style.transition = 'left 140ms cubic-bezier(.2,.8,.2,1), top 140ms cubic-bezier(.2,.8,.2,1), opacity 120ms linear';
        tileLayer.appendChild(clone);
        clones.push({clone, to: mv.to, value: mv.value});
        source.el.style.opacity = '0.15';
      }

      requestAnimationFrame(() => {
        for (const c of clones) {
          const tgtLeft = c.to[1] * cellSize;
          const tgtTop = c.to[0] * cellSize;
          c.clone.style.left = tgtLeft + 'px';
          c.clone.style.top = tgtTop + 'px';
          c.clone.style.zIndex = '30';
        }
      });

      // Taşıma tamamlanır tamamlanmaz klonları kaldır ve board'u güncelle
      setTimeout(() => {
        for (const c of clones) if (c.clone && c.clone.parentNode) c.clone.parentNode.removeChild(c.clone);
        board = newBoard.map(row => row.slice());
        renderStaticFromBoard();
        spawnTile();
        animating = false;
        if (isGameOver()) { messageElement.style.display = 'block'; }
      }, 200); // daha kısa süre: hareket bitince hemen finalize
    }

    window.addEventListener("keydown", e => {
      if (e.key === "ArrowLeft") move("left");
      if (e.key === "ArrowRight") move("right");
      if (e.key === "ArrowUp") move("up");
      if (e.key === "ArrowDown") move("down");
    });

    let startX = null, startY = null;
    window.addEventListener("touchstart", e => {
      if (e.touches.length === 1) {
        startX = e.touches[0].clientX;
        startY = e.touches[0].clientY;
      }
    }, {passive: true});
    window.addEventListener("touchend", e => {
      if (startX === null || startY === null) return;
      const dx = e.changedTouches[0].clientX - startX;
      const dy = e.changedTouches[0].clientY - startY;
      const absX = Math.abs(dx), absY = Math.abs(dy);
      const thresh = 30;
      if (Math.max(absX, absY) > thresh) {
        if (absX > absY) { if (dx > 0) move('right'); else move('left'); }
        else { if (dy > 0) move('down'); else move('up'); }
      }
      startX = null; startY = null;
    }, {passive: true});

    function newGame() {
      board = Array.from({length: SIZE}, () => Array(SIZE).fill(0));
      tileLayer.innerHTML = '';
      for (const k in domTiles) delete domTiles[k];
      domIdCounter = 0;
      const bRect = boardElement.getBoundingClientRect();
      const pad = parseFloat(getComputedStyle(boardElement).paddingLeft) || 5;
      tileLayer.style.left = pad + 'px';
      tileLayer.style.top = pad + 'px';
      tileLayer.style.width = (bRect.width - 2*pad) + 'px';
      tileLayer.style.height = (bRect.width - 2*pad) + 'px';
      updateCellSize();
      spawnTile(); spawnTile();
      messageElement.style.display = 'none';
      renderStaticFromBoard();
    }

    window.addEventListener('load', () => {
      const bRect = boardElement.getBoundingClientRect();
      const pad = parseFloat(getComputedStyle(boardElement).paddingLeft) || 5;
      tileLayer.style.left = pad + 'px';
      tileLayer.style.top = pad + 'px';
      tileLayer.style.width = (bRect.width - 2*pad) + 'px';
      tileLayer.style.height = (bRect.width - 2*pad) + 'px';
      updateCellSize();
      newGame();
    });

    messageElement.addEventListener('click', () => { newGame(); });
  </script>
</body>
</html>