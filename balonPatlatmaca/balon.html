<!doctype html>
<html lang="tr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Balon Patlatma - PowerUps</title>
<meta name="description" content="Hadi balon patlatalƒ±m! ≈ûimdi Pleahunt'da.">
    
<style>
  :root{
    --bg1:#071826; --bg2:#041121;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg1),var(--bg2));font-family:Inter,system-ui,Arial;color:#fff;overflow:hidden}
  #hud{
    position:fixed;top:10px;left:50%;transform:translateX(-50%);display:flex;gap:14px;align-items:center;
    background:rgba(0,0,0,0.35);padding:8px 14px;border-radius:12px;z-index:20;backdrop-filter:blur(4px)
  }
  #hud div{font-size:16px;display:flex;gap:8px;align-items:center}
  .effect {font-size:14px;color:#ffd;opacity:0.95;padding:6px 8px;border-radius:8px;background:rgba(255,255,255,0.02)}
  #canvas{display:block;width:100%;height:100%;touch-action:none;cursor:crosshair}
  #overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.6);z-index:30;visibility:hidden;opacity:0;transition:all .18s}
  #overlay.show{visibility:visible;opacity:1}
  .card{background:linear-gradient(180deg,#07212a,#052534);padding:22px;border-radius:12px;text-align:center;min-width:260px}
  .btn{margin-top:12px;padding:10px 16px;border-radius:10px;border:none;background:#ff6b6b;color:#041121;font-weight:700;cursor:pointer}
  .lives{display:flex;gap:6px;align-items:center}
  .heart{font-size:18px}
  @media (max-width:420px){ #hud{flex-direction:column;top:8px} }
</style>
</head>
<body>

<div id="hud">
  <div class="lives">‚ù§Ô∏è Can: <span id="lives">3</span></div>
  <div>üèÜ Puan: <span id="score">0</span></div>
  <div id="effects" style="display:flex;gap:8px">
    <div id="multIdx" class="effect" style="display:none">‚úñÔ∏è2: <span id="multTimer">0</span>s</div>
    <div id="slowIdx" class="effect" style="display:none">üê¢: <span id="slowTimer">0</span>s</div>
    <div id="crazyIdx" class="effect" style="display:none">ü§™: <span id="crazyTimer">0</span>s</div>
  </div>
</div>

<canvas id="canvas"></canvas>

<div id="overlay"><div class="card">
  <h2>Oyun Bitti!</h2>
  <p>Skorun: <strong id="finalScore">0</strong></p>
  <button id="retry" class="btn">Tekrar Oyna</button>
</div></div>

<script>
(() => {
  // ---------- CONFIG ----------
  const START_LIVES = 3;
  const BASE_SPAWN_RATE = 1.8; // avg spawn attempts per second
  const DEVICE_PIXEL_RATIO = window.devicePixelRatio || 1;

  // Ballon type probabilities (percent)
  // Crazy is very rare (0.2%)
const TYPE_PROBS = [
    {type:'explosive',  prob:7,   emoji:'üí•'},
    {type:'crazy',      prob:0.2, emoji:'ü§™'},   // %0.2
    {type:'mult',       prob:3,   emoji:'‚úñÔ∏è2'},   // %4
    {type:'slow',       prob:4,   emoji:'üê¢'},    // %5
    {type:'split',      prob:11,  emoji:'üîµ'},
    {type:'normal',     prob:76.8,emoji:''}       // normal artƒ±k emojisiz
];


  // Normalize and create cumulative weight array for selection
  const totalProb = TYPE_PROBS.reduce((s,p)=>s+p.prob,0);
  const cumulative = [];
  let acc=0;
  for(const p of TYPE_PROBS){ acc += p.prob/totalProb; cumulative.push({cut:acc,type:p.type,emoji:p.emoji}); }

  // Effect durations
  const DURATION = { crazy:30, mult:15, slow:15 };

  // ---------- STATE ----------
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d', { alpha: false });
  let W = 0, H = 0;
  let balloons = [];
  let particles = [];
  let score = 0;
  let lives = START_LIVES;
  let running = true;
  let lastTS = performance.now();
  let spawnAccumulator = 0;

  // Active effects
  const effects = {
    multActive: false, multTimer: 0,
    slowActive: false, slowTimer: 0,
    crazyActive: false, crazyTimer: 0
  };

  // DOM
  const livesEl = document.getElementById('lives');
  const scoreEl = document.getElementById('score');
  const overlay = document.getElementById('overlay');
  const finalScore = document.getElementById('finalScore');
  const retryBtn = document.getElementById('retry');
  const multIdx = document.getElementById('multIdx');
  const slowIdx = document.getElementById('slowIdx');
  const crazyIdx = document.getElementById('crazyIdx');
  const multTimerEl = document.getElementById('multTimer');
  const slowTimerEl = document.getElementById('slowTimer');
  const crazyTimerEl = document.getElementById('crazyTimer');

  // ---------- UTIL ----------
  function rand(min,max){ return Math.random()*(max-min)+min; }
  function randInt(min,max){ return Math.floor(rand(min,max+1)); }
  function chooseType(){
    const r = Math.random();
    for(const c of cumulative) if(r <= c.cut) return c.type;
    return 'normal';
  }
  function makeAudio(){ try { return new (window.AudioContext||window.webkitAudioContext)(); } catch(e){ return null; } }
  const audioCtx = makeAudio();

  function popSound(){
    if(!audioCtx) return;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'square';
    o.frequency.value = rand(400,900);
    g.gain.value = 0.12;
    o.connect(g); g.connect(audioCtx.destination);
    o.start();
    g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.12);
    o.stop(audioCtx.currentTime + 0.13);
  }

  // ---------- BALLOON CLASS ----------
  class Balloon {
    constructor(opts = {}) {
      this.type = opts.type || chooseType(); // normal | explosive | crazy | mult | slow | split
      this.emoji = getEmojiForType(this.type);
      this.r = opts.r || rand(18,44);
      this.x = opts.x || this.r + Math.random()*(W - this.r*2);
      this.y = opts.y || H + this.r + rand(0,120);
      this.baseSpeed = opts.speed || rand(40,120); // px/sec
      this.speed = this.baseSpeed;
      this.sway = rand(8,40);
      this.phase = Math.random()*Math.PI*2;
      this.popped = false;
      this.colorHue = randInt(0,360);
      this.splitCount = 0; // how many times it already split
      // crazy type shows emoji prominently; normal can show emoji too (üéà)
      if(this.type === 'crazy'){ this.emoji = 'ü§™'; }
    }
    update(dt){
      // apply global slow/crazy multipliers
      let globalFactor = 1;
      if(effects.slowActive) globalFactor *= 0.5; // slow effect reduces speed
      if(effects.crazyActive) globalFactor *= 0.2; // crazy slows a bit too
      this.speed = this.baseSpeed * globalFactor;
      this.y -= this.speed * dt;
      this.x += Math.sin(this.phase + this.y/80) * (this.sway * dt);
    }
    draw(gctx){
      // Draw balloon body (circle) with gradient
      const px = this.x, py = this.y, pr = this.r;
      const hue = this.colorHue;
      const light = `hsl(${hue},70%,60%)`;
      const dark = `hsl(${hue},70%,45%)`;
      // circle
      gctx.beginPath();
      const g = gctx.createRadialGradient(px - pr*0.25, py - pr*0.35, pr*0.1, px, py, pr);
      g.addColorStop(0, 'rgba(255,255,255,0.9)');
      g.addColorStop(0.12, light);
      g.addColorStop(1, dark);
      gctx.fillStyle = g;
      gctx.ellipse(px, py, pr*0.9, pr, 0, 0, Math.PI*2);
      gctx.fill();
      // highlight
      gctx.beginPath();
      gctx.fillStyle = 'rgba(255,255,255,0.22)';
      gctx.ellipse(px - pr*0.25, py - pr*0.35, pr*0.25, pr*0.35, 0, 0, Math.PI*2);
      gctx.fill();
      // string
      gctx.beginPath();
      gctx.strokeStyle = 'rgba(255,255,255,0.08)';
      gctx.lineWidth = 1.1;
      gctx.moveTo(px, py + pr*0.9);
      gctx.lineTo(px + Math.sin(py/50)*8, py + pr*1.6);
      gctx.stroke();

      // draw emoji text centered
      gctx.font = Math.max(12, pr) + "px serif";
      gctx.textAlign = 'center';
      gctx.textBaseline = 'middle';
      // crazy mode: always emoji; otherwise show emoji for special types, normal use small üéà
      let txt = this.emoji;
      if(this.type === 'normal' && !effects.crazyActive) txt = ''; // normal balon emoji g√∂sterme
      gctx.fillText(txt, px, py+1);
      gctx.fillStyle = 'white';
      gctx.fillText(txt, px, py);
    }
    isOffscreen(){ return this.y + this.r < -40; }
  }

  function getEmojiForType(t){
    switch(t){
      case 'explosive': return 'üí•';
      case 'crazy':     return 'ü§™';
      case 'mult':      return '‚úñÔ∏è';
      case 'slow':      return 'üê¢';
      case 'split':     return 'üîµ';
    }
  }

  // ---------- PARTICLES (small effect) ----------
  function spawnParticles(x,y,count=8){
    for(let i=0;i<count;i++){
      particles.push({
        x,y,
        vx: rand(-120,120),
        vy: rand(-220,-60),
        life: rand(0.4,0.9),
        t:0,
        size: rand(2,5)
      });
    }
  }

  // ---------- SPAWN LOGIC ----------
  function trySpawn(dt){
    spawnAccumulator += dt * BASE_SPAWN_RATE;
    while(spawnAccumulator >= 1){
      spawnAccumulator -= 1;
      // Each "attempt" will create a balloon with some probability.
      // We also want to allow rare crazy ones: choose type with weighted selection.
      const chosen = chooseType();
      // If crazy is chosen but extremely rare, it's OK.
      // Create balloon with chosen type
      const b = new Balloon({ type: chosen });
      // If split or explosive maybe slightly larger/special color
      if(b.type === 'explosive') b.r *= 1.05;
      if(b.type === 'split') b.r *= 1.0;
      balloons.push(b);
    }
  }

  // ---------- HIT / POP LOGIC ----------
  function popBalloonAtIndex(i){
    const b = balloons[i];
    if(!b) return;
    // Score calculation: base + multipliers
    let baseScore = 1;
    if(b.type === 'explosive') baseScore = 1;
    if(b.type === 'split') baseScore = 1;
    // crazy multiplier 5x, mult 2x
    let totalMultiplier = 1;
    if(effects.multActive) totalMultiplier *= 2;
    if(effects.crazyActive) totalMultiplier *= 5;
    const gained = Math.round(baseScore * totalMultiplier);
    score += gained;
    scoreEl.textContent = score;

    // particle + pop sound
    spawnParticles(b.x, b.y, Math.max(6, Math.round(b.r/5)));
    popSound();

    // Special behaviors
    if(b.type === 'explosive'){
      // remove nearby balloons within radius (150px)
      const R = 150;
      // find indices to pop (excluding itself)
      const near = [];
      for(let j = balloons.length -1; j >= 0; j--){
        if(j === i) continue;
        const o = balloons[j];
        const dx = o.x - b.x, dy = o.y - b.y;
        if(dx*dx + dy*dy <= R*R) near.push(j);
      }
      // pop them
      for(const idx of near) {
        const ob = balloons[idx];
        spawnParticles(ob.x, ob.y, Math.max(4, Math.round(ob.r/6)));
        // add score for chain (respect multipliers)
        score += Math.round(1 * totalMultiplier);
        scoreEl.textContent = score;
        balloons.splice(idx,1);
      }
      // remove explosive itself
      balloons.splice(i,1);
      return;
    }

    if(b.type === 'split'){
      // remove original
      balloons.splice(i,1);
      // spawn 1 or 2 small balloons at position
      const pieces = Math.random() < 0.5 ? 1 : 2;
      for(let k=0;k<pieces;k++){
        const small = new Balloon({
          type: 'normal',
          r: Math.max(10, b.r * rand(0.45,0.7)),
          x: b.x + rand(-12,12),
          y: b.y + rand(-6,6),
          speed: b.baseSpeed * rand(1.05,1.35)
        });
        balloons.push(small);
      }
      return;
    }

    if(b.type === 'crazy'){
      // activate crazy effect
      activateEffect('crazy', DURATION.crazy);
      // remove the crazy balloon
      balloons.splice(i,1);
      return;
    }

    if(b.type === 'mult'){
      activateEffect('mult', DURATION.mult);
      balloons.splice(i,1);
      return;
    }

    if(b.type === 'slow'){
      activateEffect('slow', DURATION.slow);
      balloons.splice(i,1);
      return;
    }

    // normal default removal
    balloons.splice(i,1);
  }

  // ---------- EFFECTS ----------
  function activateEffect(name, seconds){
    if(name === 'mult'){
      effects.multActive = true;
      effects.multTimer = seconds;
      multIdx.style.display = 'inline-block';
    } else if(name === 'slow'){
      effects.slowActive = true;
      effects.slowTimer = seconds;
      slowIdx.style.display = 'inline-block';
    } else if(name === 'crazy'){
      effects.crazyActive = true;
      effects.crazyTimer = seconds;
      crazyIdx.style.display = 'inline-block';
      // start background color cycling (handled in render)
    }
  }

  // ---------- INPUT (pointer) ----------
  function getPointerPos(e){
    const rect = canvas.getBoundingClientRect();
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    const x = (clientX - rect.left) * (canvas.width / rect.width);
    const y = (clientY - rect.top)  * (canvas.height / rect.height);
    return {x: x / DEVICE_PIXEL_RATIO, y: y / DEVICE_PIXEL_RATIO};
  }
  // pointerdown
  canvas.addEventListener('pointerdown', (e) => {
    if(!running) return;
    const p = getPointerPos(e);
    // find topmost balloon hit (reverse order)
    for(let i = balloons.length -1; i>=0; i--){
      const b = balloons[i];
      const dx = p.x - b.x;
      const dy = p.y - b.y;
      if(dx*dx + dy*dy <= (b.r*b.r)){
        popBalloonAtIndex(i);
        return;
      }
    }
  }, {passive:true});

  // ---------- GAME LOOP ----------
  function resize(){
    // size canvas to device pixels
    const cssW = window.innerWidth;
    const cssH = window.innerHeight;
    canvas.style.width = cssW + 'px';
    canvas.style.height = cssH + 'px';
    canvas.width = Math.max(600, Math.floor(cssW * DEVICE_PIXEL_RATIO));
    canvas.height = Math.max(400, Math.floor(cssH * DEVICE_PIXEL_RATIO));
    W = canvas.width / DEVICE_PIXEL_RATIO;
    H = canvas.height / DEVICE_PIXEL_RATIO;
    ctx.setTransform(DEVICE_PIXEL_RATIO,0,0,DEVICE_PIXEL_RATIO,0,0);
  }
  window.addEventListener('resize', resize);
  resize();

  function endGame(){
    running = false;
    finalScore.textContent = score;
    overlay.classList.add('show');
  }
  retryBtn.addEventListener('click', () => {
    // reset
    overlay.classList.remove('show');
    score = 0; lives = START_LIVES;
    effects.multActive = effects.slowActive = effects.crazyActive = false;
    effects.multTimer = effects.slowTimer = effects.crazyTimer = 0;
    balloons = []; particles = [];
    livesEl.textContent = lives;
    scoreEl.textContent = score;
    running = true;
    lastTS = performance.now();
    requestAnimationFrame(tick);
  });

  function tick(ts){
    if(!running) return;
    const dt = Math.min(0.06, (ts - lastTS)/1000);
    lastTS = ts;

    // update effects timers
    if(effects.multActive){
      effects.multTimer -= dt;
      multTimerEl.textContent = Math.ceil(Math.max(0, effects.multTimer));
      if(effects.multTimer <= 0){ effects.multActive = false; multIdx.style.display = 'none'; }
    }
    if(effects.slowActive){
      effects.slowTimer -= dt;
      slowTimerEl.textContent = Math.ceil(Math.max(0, effects.slowTimer));
      if(effects.slowTimer <= 0){ effects.slowActive = false; slowIdx.style.display = 'none'; }
    }
    if(effects.crazyActive){
      effects.crazyTimer -= dt;
      crazyTimerEl.textContent = Math.ceil(Math.max(0, effects.crazyTimer));
      if(effects.crazyTimer <= 0){ effects.crazyActive = false; crazyIdx.style.display = 'none'; }
    }

    // spawn
    trySpawn(dt);

    // update balloons
    for(let i = balloons.length-1; i>=0; i--){
      const b = balloons[i];
      b.update(dt);
      // if offscreen (reached top) -> lose a life
      if(b.isOffscreen()){
        // remove and decrement life
        balloons.splice(i,1);
        // negative visual effect (small particle)
        spawnParticles(b.x, -20, 6);
        lives--;
        livesEl.textContent = lives;
        if(lives <= 0){
          endGame();
          return;
        }
      }
    }

    // update particles
    for(let i=particles.length-1;i>=0;i--){
      const p = particles[i];
      p.t += dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vy += 350 * dt;
      if(p.t > p.life) particles.splice(i,1);
    }

    render();

    requestAnimationFrame(tick);
  }

  // ---------- RENDER ----------
  // crazy mode background helper


const crazyColors = [
  '#ff0000','#00ff00','#0000ff','#ffff00',
  '#ff00ff','#00ffff','#ffa500','#800080',
  '#008000','#ff1493'
];
let crazyIndex = 0;

function render(){
  // background
  if(effects.crazyActive){
    document.body.style.background = `linear-gradient(180deg, ${crazyColors[crazyIndex % crazyColors.length]}, ${crazyColors[(crazyIndex+1) % crazyColors.length]})`;
    crazyIndex++;
  } else {
    document.body.style.background = 'linear-gradient(180deg, #071826, #041121)';
  }

  // clear canvas
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // draw balloons
  for(const b of balloons) b.draw(ctx);

  // draw particles
  for(const p of particles){
    ctx.beginPath();
    const alpha = Math.max(0, 1 - p.t / p.life);
    ctx.fillStyle = `rgba(255,255,255,${alpha})`;
    ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
    ctx.fill();
  }

    // clear
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // draw balloons
    for(const b of balloons) b.draw(ctx);

    // draw particles
    for(const p of particles){
      ctx.beginPath();
      const alpha = Math.max(0, 1 - p.t / p.life);
      ctx.fillStyle = `rgba(255,255,255,${alpha})`;
      ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
      ctx.fill();
    }
  }

  // ---------- INIT ----------
  function init(){
    // ensure HUD initial states
    scoreEl.textContent = score;
    livesEl.textContent = lives;
    multIdx.style.display = 'none';
    slowIdx.style.display = 'none';
    crazyIdx.style.display = 'none';
    lastTS = performance.now();
    requestAnimationFrame(tick);
  }

  // ---------- POINTER (touch) compatibility fallback ----------
  // pointerdown already used; also add touchstart passive/no-default for mobile
  canvas.addEventListener('touchstart', (e)=>{ e.preventDefault(); }, {passive:false});

  // ---------- Start ----------
  init();

  // Expose small debug helpers (optional)
  window._spawn = () => { balloons.push(new Balloon({type:chooseType()})); };
  window._state = () => ({score,lives,balloons:balloons.length,effects});

})();
</script>
</body>
</html>
