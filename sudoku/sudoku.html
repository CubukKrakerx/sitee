<!doctype html>
<html lang="tr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Sudoku - Düzeltildi</title>
<style>
  :root{
    --bg:#071029; --panel:#0b1220; --cell:#0e1726; --accent:#60a5fa; --ok:#10b981; --bad:#ef4444; --text:#e6eef8;
  }
  html,body{height:100%;margin:0;font-family:Segoe UI,Roboto,Arial;background:linear-gradient(180deg,#071022,#081127);color:var(--text);display:flex;align-items:center;justify-content:center;padding:20px;}
  .app{width:100%;max-width:920px;background:var(--bg);border-radius:12px;padding:18px;box-shadow:0 10px 30px rgba(2,6,23,.6);}
  header{display:flex;align-items:center;justify-content:space-between;margin-bottom:12px;}
  h1{font-size:20px;margin:0;}
  .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap;}
  select,button{background:var(--panel);color:var(--text);border:1px solid rgba(255,255,255,.04);padding:8px 10px;border-radius:8px;cursor:pointer;}
  button.primary{background:linear-gradient(90deg,var(--accent),#3b82f6);border:none;color:#041025;}
  .board-wrap{display:flex;gap:18px;align-items:flex-start;}
  .board{display:grid;grid-template-columns:repeat(9,1fr);gap:4px;padding:6px;border-radius:8px;position:relative;background:linear-gradient(180deg,#081220,#021025);}
  .cell{width:54px;height:54px;display:flex;align-items:center;justify-content:center;font-size:20px;background:var(--cell);border-radius:6px;color:var(--text);position:relative;user-select:none;}
  .cell input{width:100%;height:100%;text-align:center;background:transparent;border:0;color:inherit;font-size:20px;outline:none;}
  .given{font-weight:700;color:#cfe7ff;background:linear-gradient(180deg,#081829,#062034);border:1px solid rgba(255,255,255,.03);}
  .fixed { pointer-events:none; }
  .cell.thick-right{border-right:2px solid rgba(255,255,255,.06);}
  .cell.thick-bottom{border-bottom:2px solid rgba(255,255,255,.06);}
  .side{min-width:220px;padding:10px;background:linear-gradient(180deg,#041027,#02101b);border-radius:8px;}
  .info{font-size:14px;line-height:1.4;margin-bottom:8px;}
  .small{font-size:13px;color:#a7c0db;}
  .actions{display:flex;flex-direction:column;gap:8px;}
  .hint{background:#0f1729;border:1px solid rgba(255,255,255,.03);padding:8px;border-radius:8px;color:var(--text);}
  .bad{border-color:var(--bad);box-shadow:0 0 0 3px rgba(239,68,68,.06) inset;}
  .ok{border-color:var(--ok);box-shadow:0 0 0 3px rgba(16,185,129,.06) inset;}
  footer{margin-top:12px;text-align:center;color:#9fb7d9;font-size:13px;}
  @media(max-width:820px){
    .board-wrap{flex-direction:column;align-items:center;}
    .side{width:100%;}
    .cell{width:44px;height:44px;font-size:18px;}
  }
</style>
</head>
<body>
  <div class="app" role="application" aria-label="Sudoku Uygulaması">
    <header>
      <h1>Sudoku</h1>
      <div class="controls">
        <label class="small" for="difficulty">Zorluk</label>
        <select id="difficulty">
          <option value="easy">Kolay</option>
          <option value="medium">Orta</option>
          <option value="hard">Zor</option>
        </select>
        <button id="newBtn" class="primary">Yeni Tahta</button>
        <button id="checkBtn">Kontrol Et</button>
        <button id="solveBtn">Çöz</button>
      </div>
    </header>

    <div class="board-wrap">
      <div id="board" class="board" aria-label="Sudoku Tahtası"></div>

      <aside class="side" aria-label="Yan Panel">
        <div class="info">
          <div><strong>Nasıl oyna</strong></div>
          <div class="small">Boş hücreye tıkla ve 1-9 arası sayı gir. İpucu almak için İpucu butonunu kullan.</div>
        </div>
        <div class="actions">
          <button id="hintBtn" class="hint">İpucu</button>
          <button id="eraseBtn">Sil</button>
          <button id="resetBtn">Sıfırla</button>
        </div>
        <div style="height:12px"></div>
        <div class="info"><strong>Durum</strong><div id="status" class="small">Hazır</div></div>
      </aside>
    </div>
  </div>

<script>
/* Temel veriler */
const boardEl = document.getElementById('board');
const difficultyEl = document.getElementById('difficulty');
const newBtn = document.getElementById('newBtn');
const checkBtn = document.getElementById('checkBtn');
const solveBtn = document.getElementById('solveBtn');
const hintBtn = document.getElementById('hintBtn');
const eraseBtn = document.getElementById('eraseBtn');
const resetBtn = document.getElementById('resetBtn');
const statusEl = document.getElementById('status');

let solution = [];
let puzzle = [];
let cells = []; // input elemanları
let initialMask = [];

/* Yardımcılar */
function makeEmptyMatrix(){ return Array.from({length:9},()=>Array(9).fill(0)); }

function cloneGrid(g){ return g.map(row=>row.slice()); }

/* Backtracking solver (tek veya çoklu çözüm sayısı için kullanılabilir) */
function findEmpty(grid){
  for(let r=0;r<9;r++) for(let c=0;c<9;c++) if(grid[r][c]===0) return [r,c];
  return null;
}
function isValid(grid,r,c,val){
  for(let i=0;i<9;i++){
    if(grid[r][i]===val) return false;
    if(grid[i][c]===val) return false;
  }
  const br = Math.floor(r/3)*3, bc = Math.floor(c/3)*3;
  for(let i=0;i<3;i++) for(let j=0;j<3;j++) if(grid[br+i][bc+j]===val) return false;
  return true;
}
function solveGrid(grid){
  const spot = findEmpty(grid);
  if(!spot) return true;
  const [r,c] = spot;
  for(let val=1;val<=9;val++){
    if(isValid(grid,r,c,val)){
      grid[r][c]=val;
      if(solveGrid(grid)) return true;
      grid[r][c]=0;
    }
  }
  return false;
}

/* Çoklu çözüm arayan fonksiyon, birden fazla çözüm bulunursa true döner */
function hasMultipleSolutions(grid, limit=2){
  let count = 0;
  function dfs(g){
    if(count>=limit) return;
    const spot = findEmpty(g);
    if(!spot){ count++; return; }
    const [r,c] = spot;
    for(let v=1;v<=9;v++){
      if(isValid(g,r,c,v)){
        g[r][c]=v;
        dfs(g);
        g[r][c]=0;
        if(count>=limit) return;
      }
    }
  }
  dfs(cloneGrid(grid));
  return count>=2;
}

/* Tamamen doldurulmuş geçerli grid üret */
function generateCompletedGrid(){
  const g = makeEmptyMatrix();
  // diagonal blokları rastgele doldur, bu çözmeyi kolaylaştırır
  function fillBlock(br,bc){
    const nums = [1,2,3,4,5,6,7,8,9].sort(()=>Math.random()-0.5);
    let idx=0;
    for(let r=0;r<3;r++) for(let c=0;c<3;c++) g[br+r][bc+c]=nums[idx++];
  }
  fillBlock(0,0); fillBlock(3,3); fillBlock(6,6);
  solveGrid(g);
  return g;
}

/* Puzzle üretimi: çözümü koruyarak hücreleri kaldır, benzersizliği kontrol et */
function generatePuzzle(difficulty='easy'){
  const full = generateCompletedGrid();
  const grid = cloneGrid(full);
  // kaldırma miktarı zorlukla ilişkilendirildi
  const removals = difficulty==='easy'? 36 : difficulty==='medium'? 46 : 54;
  const positions = [];
  for(let r=0;r<9;r++) for(let c=0;c<9;c++) positions.push([r,c]);
  // karıştır
  for(let i=positions.length-1;i>0;i--){
    const j=Math.floor(Math.random()*(i+1)); [positions[i],positions[j]]=[positions[j],positions[i]];
  }
  let removed=0;
  for(const [r,c] of positions){
    if(removed>=removals) break;
    const backup = grid[r][c];
    grid[r][c]=0;
    // eğer 2 veya daha fazla çözüm varsa geri al
    if(hasMultipleSolutions(grid)){
      grid[r][c]=backup;
    } else {
      removed++;
    }
  }
  return {puzzle:grid, solution:full};
}

/* UI: tahta kur */
function buildBoard(){
  boardEl.innerHTML='';
  cells = [];
  for(let r=0;r<9;r++){
    for(let c=0;c<9;c++){
      const wrapper = document.createElement('div');
      wrapper.className='cell';
      if((c+1)%3===0 && c!==8) wrapper.classList.add('thick-right');
      if((r+1)%3===0 && r!==8) wrapper.classList.add('thick-bottom');
      const input = document.createElement('input');
      input.type='text';
      input.inputMode='numeric';
      input.maxLength=1;
      input.dataset.r = r; input.dataset.c = c;
      input.autocomplete = 'off';
      input.spellcheck = false;
      input.addEventListener('input', onCellInput);
      input.addEventListener('keydown', onCellKeyDown);
      wrapper.appendChild(input);
      boardEl.appendChild(wrapper);
      cells.push(input);
    }
  }
}

/* Load puzzle to UI */
function loadPuzzle(mat,sol){
  puzzle = mat.map(r=>r.slice());
  solution = sol.map(r=>r.slice());
  initialMask = mat.map(row=>row.map(v=>v!==0));
  for(let r=0;r<9;r++) for(let c=0;c<9;c++){
    const idx=r*9+c;
    const inp=cells[idx];
    const v=puzzle[r][c];
    inp.value = v===0 ? '' : String(v);
    if(v!==0){
      inp.parentElement.classList.add('given','fixed');
      inp.dataset.initial='1';
      inp.disabled = true;
    } else {
      inp.parentElement.classList.remove('given','fixed');
      inp.dataset.initial='0';
      inp.disabled = false;
    }
    inp.parentElement.classList.remove('bad','ok');
  }
  statusEl.textContent = 'Tahta yüklendi';
}

/* Input olayları */
function onCellInput(e){
  const input = e.target;
  const r = +input.dataset.r, c = +input.dataset.c;
  const clean = input.value.replace(/[^1-9]/g,'');
  input.value = clean;
  if(clean===''){ puzzle[r][c]=0; input.parentElement.classList.remove('bad','ok'); return; }
  const num = parseInt(clean,10);
  puzzle[r][c]=num;
  if(isValidPlacementVisual(r,c,num)){
    input.parentElement.classList.add('ok'); input.parentElement.classList.remove('bad');
  } else {
    input.parentElement.classList.add('bad'); input.parentElement.classList.remove('ok');
  }
}

function onCellKeyDown(e){
  const key=e.key;
  if(['ArrowLeft','ArrowRight','ArrowUp','ArrowDown'].includes(key)){
    e.preventDefault(); moveFocus(e.target,key);
  } else if(key==='Backspace' || key==='Delete'){
    const r=+e.target.dataset.r,c=+e.target.dataset.c;
    if(initialMask[r][c]){ statusEl.textContent='Sabit hücre silinemez'; return; }
    e.target.value=''; puzzle[r][c]=0; e.target.parentElement.classList.remove('bad','ok');
  } else if(/^[1-9]$/.test(key)){
    // allow natural typing, handled in input event
  } else if(key.length===1){
    e.preventDefault();
  }
}

function moveFocus(el, dir){
  const r=+el.dataset.r,c=+el.dataset.c;
  let nr=r,nc=c;
  if(dir==='ArrowLeft') nc = c>0?c-1:8;
  if(dir==='ArrowRight') nc = c<8?c+1:0;
  if(dir==='ArrowUp') nr = r>0?r-1:8;
  if(dir==='ArrowDown') nr = r<8?r+1:0;
  const next = cells[nr*9+nc];
  next.focus(); next.select();
}

/* Görsel validasyon: mevcut puzzle'a göre geçerli mi */
function isValidPlacementVisual(r,c,val){
  if(val<1||val>9) return false;
  for(let i=0;i<9;i++){
    if(i!==c && puzzle[r][i]===val) return false;
    if(i!==r && puzzle[i][c]===val) return false;
  }
  const br=Math.floor(r/3)*3, bc=Math.floor(c/3)*3;
  for(let i=0;i<3;i++) for(let j=0;j<3;j++){
    const rr=br+i, cc=bc+j;
    if((rr!==r||cc!==c) && puzzle[rr][cc]===val) return false;
  }
  return true;
}

/* Kontrol et */
function checkSolution(){
  for(let r=0;r<9;r++) for(let c=0;c<9;c++){
    if(puzzle[r][c]===0){ statusEl.textContent='Eksik hücreler var'; return false; }
    if(puzzle[r][c]!==solution[r][c]){ statusEl.textContent='Yanlış çözüm'; return false; }
  }
  statusEl.textContent='Tebrikler! Doğru çözdünüz';
  return true;
}

/* İpucu */
function hint(){
  const empties=[];
  for(let r=0;r<9;r++) for(let c=0;c<9;c++) if(puzzle[r][c]===0) empties.push([r,c]);
  if(empties.length===0){ statusEl.textContent='Boş hücre yok'; return; }
  const [r,c]=empties[Math.floor(Math.random()*empties.length)];
  puzzle[r][c]=solution[r][c];
  const inp=cells[r*9+c];
  inp.value=String(solution[r][c]);
  inp.parentElement.classList.add('ok');
  statusEl.textContent='İpucu yerleştirildi';
}

/* Sıfırla: kullanıcı tarafından doldurulanları temizle, sabitleri koru */
function resetToInitial(){
  for(let r=0;r<9;r++) for(let c=0;c<9;c++){
    if(initialMask[r][c]){
      puzzle[r][c]=solution[r][c];
    } else {
      puzzle[r][c]=0;
    }
  }
  for(let r=0;r<9;r++) for(let c=0;c<9;c++){
    const inp=cells[r*9+c];
    if(initialMask[r][c]){ inp.value=String(puzzle[r][c]); inp.parentElement.classList.add('given'); inp.disabled=true; }
    else { inp.value=''; inp.parentElement.classList.remove('given'); inp.disabled=false; }
    inp.parentElement.classList.remove('bad','ok');
  }
  statusEl.textContent='Tahta sıfırlandı';
}

/* Çözüm göster */
function autoSolve(){
  for(let r=0;r<9;r++) for(let c=0;c<9;c++){
    puzzle[r][c]=solution[r][c];
    const inp=cells[r*9+c];
    inp.value=String(solution[r][c]);
    inp.parentElement.classList.remove('bad');
    inp.parentElement.classList.add('ok');
  }
  statusEl.textContent='Tahta çözüldü';
}

/* Yeni tahta */
function newBoard(){
  statusEl.textContent='Tahta üretiliyor...';
  const diff = difficultyEl.value;
  // generate puzzle (senkron); küçük gecikme yaşanabilir ama mantık doğru
  const gen = generatePuzzle(diff);
  // buildBoard only once and then load puzzle; if board boşsa build it
  if(cells.length===0) buildBoard();
  loadPuzzle(gen.puzzle, gen.solution);
}

/* Başlangıç */
buildBoard();
const initial = generatePuzzle('easy');
loadPuzzle(initial.puzzle, initial.solution);

/* Eventler */
newBtn.addEventListener('click', ()=>{ newBoard(); });
checkBtn.addEventListener('click', ()=>{ checkSolution(); });
solveBtn.addEventListener('click', ()=>{ autoSolve(); });
hintBtn.addEventListener('click', ()=>{ hint(); });
eraseBtn.addEventListener('click', ()=>{
  const active = document.activeElement;
  if(active && active.tagName==='INPUT' && active.dataset.r){
    const r=+active.dataset.r,c=+active.dataset.c;
    if(initialMask[r][c]) { statusEl.textContent='Sabit hücre silinemez'; return; }
    active.value=''; puzzle[r][c]=0; active.parentElement.classList.remove('bad','ok');
  } else {
    statusEl.textContent='Hücre seçin';
  }
});
resetBtn.addEventListener('click', ()=>{ resetToInitial(); });

</script>
</body>
</html>