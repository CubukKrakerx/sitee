<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8">
  <title>Brick Breaker</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      background: #222;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
    }
    canvas {
      background: #111;
      border: 2px solid #fff;
      width: 480px;
      height: 320px;
      max-width: 100%;
      max-height: 100%;
    }
    @media (max-width: 768px) {
      body {
        height: auto;
        display: block;
        padding: 10px;
      }
      canvas {
        width: 100%;
        height: auto;
        border-width: 1.5px;
      }
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="480" height="320"></canvas>
  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    // Top
    let ballRadius = 8;
    let x = canvas.width / 2;
    let y = canvas.height - 30;
    let dx = 2;
    let dy = -2;

    // Paddle
    const paddleHeight = 10;
    const paddleWidth = 75;
    let paddleX = (canvas.width - paddleWidth) / 2;
    let rightPressed = false;
    let leftPressed = false;

    // Tuƒülalar
    const brickRowCount = 8;
    const brickColumnCount = 10;
    const brickWidth = 40;
    const brickHeight = 20;
    // Tuƒülalar arasƒ± bo≈üluk. √áok b√ºy√ºk olursa tuƒülalar canvas'tan ta≈üabilir.
    const brickPadding = 5;
    const brickOffsetTop = 30;

    const totalBricksWidth = brickColumnCount * brickWidth + (brickColumnCount - 1) * brickPadding;
    const brickOffsetLeft = (canvas.width - totalBricksWidth) / 2;

    let bricks = [];
    let score = 0;
    let level = 1;
    const maxLevel = 12;

    let currentLevelBricks = 0;
    let brokenBricks = 0;
    let levelCleared = false;
    // Rastgele ge√ßi≈ü mantƒ±ƒüƒ± i√ßin ka√ß tur ge√ßtiƒüini takip et
    let levelsClearedCount = 0;

    let gameOver = false;
    let gameWon = false;
    let replayButton = null;

    function showMessage(text) {
      ctx.font = "24px Arial";
      ctx.fillStyle = "#fff";
      ctx.textAlign = "center";
      ctx.fillText(text, canvas.width/2, canvas.height/2 - 20);
    }

    function drawOverlay(message) {
      ctx.fillStyle = "rgba(0,0,0,0.6)";
      ctx.fillRect(canvas.width/2 - 120, canvas.height/2 - 60, 240, 120);

      ctx.fillStyle = "#fff";
      ctx.font = "18px Arial";
      ctx.textAlign = "center";
      ctx.fillText(message, canvas.width/2, canvas.height/2 - 30);
      ctx.fillText("Skor: " + score, canvas.width/2, canvas.height/2 - 5);

      ctx.fillStyle = "#ffcc00";
      ctx.fillRect(canvas.width/2 - 50, canvas.height/2 + 15, 100, 30);
      ctx.fillStyle = "#000";
      ctx.font = "16px Arial";
      ctx.fillText("Tekrar Oyna", canvas.width/2, canvas.height/2 + 37);

      replayButton = {
        x: canvas.width/2 - 50,
        y: canvas.height/2 + 15,
        w: 100,
        h: 30
      };
    }

    function initBricks() {
      bricks = [];
      currentLevelBricks = 0;
      brokenBricks = 0;
      levelCleared = false;
      for (let c = 0; c < brickColumnCount; c++) {
        bricks[c] = [];
        for (let r = 0; r < brickRowCount; r++) {
          bricks[c][r] = { x: 0, y: 0, status: 0 };
        }
      }

      // üîπ √ñrnek desenler (kare, kalp, vs.)
      if (level === 1) { for (let c = 2; c < 8; c++) for (let r = 2; r < 6; r++) bricks[c][r].status = 1; }
      else if (level === 2) {
        const heart = ["01100110","11111111","11111111","01111110","00111100"];
        for (let r = 0; r < heart.length; r++) for (let c = 0; c < heart[r].length; c++) if (heart[r][c] === "1") bricks[c+1][r+1].status = 1;
      }
      else if (level === 3) { for (let c = 0; c < brickColumnCount; c++) for (let r = 0; r < brickRowCount; r++) if ((c+r)%2===0) bricks[c][r].status=1; }
      // ... diƒüer desenler aynƒ± ≈üekilde devam ediyor
      else {
        // Eƒüer belirli bir desen bulunmuyorsa, rastgele ama oynanabilir bir desen olu≈ütur
        // Seviye numarasƒ±na baƒülƒ± olarak zorluk artƒ±≈üƒ± yapƒ±lƒ±r (daha y√ºksek seviye => daha fazla tuƒüla olma ihtimali)
        const baseChance = 0.35; // d√º≈ü√ºk seviye i√ßin ba≈ülangƒ±√ß
        const levelFactor = Math.min(0.5, level * 0.03); // seviyeye g√∂re artƒ±≈ü
        const chance = Math.min(0.85, baseChance + levelFactor);
        for (let c = 0; c < brickColumnCount; c++) {
          for (let r = 0; r < brickRowCount; r++) {
            // K√º√ß√ºk rastgelelik; kenarlarda daha az olma eƒüilimi i√ßin bias ekleyelim
            const edgeBias = (c === 0 || c === brickColumnCount - 1) ? 0.7 : 1;
            if (Math.random() < chance * edgeBias) bricks[c][r].status = 1;
          }
        }
      }

      for (let c = 0; c < brickColumnCount; c++) {
        for (let r = 0; r < brickRowCount; r++) {
          if (bricks[c][r].status === 1) currentLevelBricks++;
        }
      }
    }
    initBricks();

    document.addEventListener("keydown", e => {
      if (e.key === "Right" || e.key === "ArrowRight") rightPressed = true;
      else if (e.key === "Left" || e.key === "ArrowLeft") leftPressed = true;
    });
    document.addEventListener("keyup", e => {
      if (e.key === "Right" || e.key === "ArrowRight") rightPressed = false;
      else if (e.key === "Left" || e.key === "ArrowLeft") leftPressed = false;
    });

    canvas.addEventListener("click", e => {
      if (replayButton) {
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;
        if (mx > replayButton.x && mx < replayButton.x + replayButton.w &&
            my > replayButton.y && my < replayButton.y + replayButton.h) {
          score = 0;
          level = 1;
          levelsClearedCount = 0;
          x = canvas.width/2;
          y = canvas.height - 30;
          dx = 2;
          dy = -2;
          paddleX = (canvas.width - paddleWidth)/2;
          gameOver = false;
          gameWon = false;
          initBricks();
        }
      }
    });

    // --- Mobil & fare (pointer) kontrolleri ---
    function getCanvasXFromEvent(ev) {
      const rect = canvas.getBoundingClientRect();
      const touch = (ev.touches && ev.touches[0]) ? ev.touches[0] : null;
      const clientX = touch ? touch.clientX : ev.clientX;
      const clientY = touch ? touch.clientY : ev.clientY;
      // Eƒüer event canvas dƒ±≈üƒ±ndaysa null d√∂nd√ºr (etki etmesin)
      if (clientX < rect.left || clientX > rect.right || clientY < rect.top || clientY > rect.bottom) return null;
      // internal canvas size may differ from CSS size; √∂l√ßekte d√ºzeltme
      const scaleX = canvas.width / rect.width;
      return (clientX - rect.left) * scaleX;
    }

    // Fare hareketi ile paddle kontrol√º (masa√ºst√º)
    canvas.addEventListener('mousemove', e => {
      const mx = getCanvasXFromEvent(e);
      if (mx === null) return; // harita dƒ±≈üƒ±ndaysa paddle etkilenmesin
      paddleX = Math.max(0, Math.min(canvas.width - paddleWidth, mx - paddleWidth / 2));
    });

    // Touch hareketi (mobil)
    canvas.addEventListener('touchstart', e => {
      const mx = getCanvasXFromEvent(e);
      if (mx === null) return;
      paddleX = Math.max(0, Math.min(canvas.width - paddleWidth, mx - paddleWidth / 2));
    }, { passive: true });

    canvas.addEventListener('touchmove', e => {
      e.preventDefault(); // paddle s√ºr√ºklemesi yaparken sayfa kaymasƒ±nƒ± engelle
      const mx = getCanvasXFromEvent(e);
      if (mx === null) return;
      paddleX = Math.max(0, Math.min(canvas.width - paddleWidth, mx - paddleWidth / 2));
    }, { passive: false });

    function collisionDetection() {
      for (let c = 0; c < brickColumnCount; c++) {
        for (let r = 0; r < brickRowCount; r++) {
          let b = bricks[c][r];
          if (b.status === 1) {
            if (x+ballRadius > b.x && x-ballRadius < b.x+brickWidth &&
                y+ballRadius > b.y && y-ballRadius < b.y+brickHeight) {

              let overlapX = Math.min(x + ballRadius - b.x, b.x + brickWidth - (x - ballRadius));
              let overlapY = Math.min(y + ballRadius - b.y, b.y + brickHeight - (y - ballRadius));
              if (overlapX < overlapY) dx = -dx; else dy = -dy;

              b.status = 0;
              score++;
              brokenBricks++;

              // Hƒ±zlanma artƒ±k tuƒüla ba≈üƒ±na k√º√ß√ºk sabit artƒ±≈ütan ziyade
              // seviye temelli ve vekt√∂r b√ºy√ºkl√ºƒü√ºn√º sƒ±nƒ±rlayan bir yakla≈üƒ±m kullanƒ±r.
              const inc = 0.02 + level * 0.003; // seviye arttƒ±k√ßa biraz daha hƒ±zlƒ± olma eƒüilimi
              dx = dx > 0 ? dx + inc : dx - inc;
              dy = dy > 0 ? dy + inc : dy - inc;
              // Vekt√∂r hƒ±zƒ±nƒ± sƒ±nƒ±rlayalƒ±m (dx/dy birlikte kontrol edilecek)
              clampSpeed();

              // Seviye ger√ßekten tuƒülalardan olu≈üuyorsa temizlenmi≈ü kabul edilsin.
              if (currentLevelBricks > 0 && brokenBricks === currentLevelBricks && !levelCleared) {
                levelCleared = true;
                setTimeout(() => {
                  // Bir seviyeyi temizledik
                  levelsClearedCount++;
                  if (levelsClearedCount >= maxLevel) {
                    gameWon = true;
                  } else {
                    // Sƒ±radaki seviye rastgele se√ßilsin (aynƒ± seviye gelmesin)
                    let next = Math.floor(Math.random() * maxLevel) + 1;
                    // g√ºvenlik d√∂ng√ºs√º - aynƒ± seviyeyi birka√ß defa alma durumunu engelle
                    let tries = 0;
                    while (next === level && tries < 8) { next = Math.floor(Math.random() * maxLevel) + 1; tries++; }
                    level = next;
                    initBricks();
                  }
                }, 300);
              }
            }
          }
        }
      }
    }

    function drawBall() {
      ctx.beginPath();
      ctx.arc(x, y, ballRadius, 0, Math.PI * 2);
      ctx.fillStyle = "#00ffcc";
      ctx.fill();
      ctx.closePath();
    }

    function drawPaddle() {
      ctx.beginPath();
      ctx.rect(paddleX, canvas.height - paddleHeight - 5, paddleWidth, paddleHeight);
      ctx.fillStyle = "#ffcc00";
      ctx.fill();
      ctx.closePath();
    }

    function drawBricks() {
      for (let c = 0; c < brickColumnCount; c++) {
        for (let r = 0; r < brickRowCount; r++) {
          if (bricks[c][r].status === 1) {
            let brickX = c * (brickWidth + brickPadding) + brickOffsetLeft;
            let brickY = r * (brickHeight + brickPadding) + brickOffsetTop;
            bricks[c][r].x = brickX;
            bricks[c][r].y = brickY;
            ctx.beginPath();
            ctx.rect(brickX, brickY, brickWidth, brickHeight);
            ctx.fillStyle = `hsl(${level*30},70%,50%)`;
            ctx.fill();
            ctx.closePath();
          }
        }
      }
    }

    function drawScore() {
      ctx.font = "16px Arial";
      ctx.fillStyle = "#fff";
      ctx.fillText("Skor: " + score, 8, 20);
      ctx.fillText("B√∂l√ºm: " + level + ' (Kalan: ' + Math.max(0, currentLevelBricks - brokenBricks) + ')', canvas.width - 200, 20);
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawBricks();
      drawBall();
      drawPaddle();
      drawScore();
      collisionDetection();

      // Overlay kontrol√º
      if (gameOver) {
        drawOverlay("Oyun Bitti üò¢");
      }
      if (gameWon) {
        drawOverlay("Tebrikler! T√ºm b√∂l√ºmleri ge√ßtin üéâ");
      }

      // Normal oyun akƒ±≈üƒ±
      if (!gameOver && !gameWon) {
        if (x + dx > canvas.width - ballRadius || x + dx < ballRadius) dx = -dx;
        if (y + dy < ballRadius) dy = -dy;
        else if (y + dy > canvas.height - ballRadius) {
          if (x > paddleX && x < paddleX + paddleWidth) {
            // Paddle merkezine g√∂re topun yatay hƒ±zƒ±nƒ± hafif√ße deƒüi≈ütirerek oyuncuya kontrol veriyoruz.
            const paddleCenter = paddleX + paddleWidth / 2;
            const distanceFromCenter = (x - paddleCenter) / (paddleWidth / 2); // -1 .. 1
            dx += distanceFromCenter * 0.7; // √ßok b√ºy√ºk olmamalƒ±, oynanƒ±≈üƒ± bozmamak i√ßin k√º√ß√ºk bir √ßarpan
            // Hƒ±zƒ± makul seviyede sƒ±nƒ±rlayalƒ±m
            // topun toplam hƒ±zƒ± seviye ve durumuna g√∂re sƒ±nƒ±rlandƒ±r
            clampSpeed();
            // Top yukarƒ± doƒüru kesinlikle gitsin
            dy = -Math.abs(dy);
          } else {
            gameOver = true;
          }
        }

        if (rightPressed && paddleX < canvas.width - paddleWidth) paddleX += 5;
        else if (leftPressed && paddleX > 0) paddleX -= 5;

        x += dx;
        y += dy;
      }

      requestAnimationFrame(draw);
    }

    draw();

    // Hƒ±zƒ± sƒ±nƒ±rlandƒ±rmak i√ßin vekt√∂r bazlƒ± kontrol
    function clampSpeed() {
      const minMax = 6; // taban sƒ±nƒ±r
      // seviyeye g√∂re biraz daha geni≈ület
      const levelBoost = Math.min(5, level * 0.3);
      const maxVelocity = minMax + levelBoost; // √∂rn. seviye 10'da ~9
      const speed = Math.sqrt(dx * dx + dy * dy);
      if (speed > maxVelocity) {
        const scale = maxVelocity / speed;
        dx *= scale;
        dy *= scale;
      }
    }
  </script>
</body>
</html>
